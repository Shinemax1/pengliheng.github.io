    <div class="container-context container">

      <div class="col-sm-12">
        <h3>object</h3>
        <h4>no-new-object</h4>
        <pre>
          //bad 
          const item = new Object();

          //god
          const item = {};
        </pre>
        <h4>property names</h4>
        <pre>
          function getKey(k){
            return 'a key named ${k}';
          }

          //bad
          const obj = {
            id : 5,
            name:"San francisco"
          };
          obj[getKey('enabled')] = true;

          //good
          const obj = {
            id:5,
            name:"san francisco",
            [getKey('enabled')]:true
          };
        </pre>
        <h4>use boject method </h4>
        <pre>
          //bad
          const atom = {
            value:1,
            addValue: function(value){
              return atom.value + value;
            }
          }
          //good 
          const atom = {
            value:1,
            addValue(value){
              return atom.value + value;
            }
          }
        </pre>
        <h4>short to descript</h4>
        <pre>
          const luckPerson = "luck person";

          //bad
          cosnt obj = {
            luckPerson:luckPerson
          }

          //good
          const obj = {
            luckPerson
          }
        </pre>
        <h4>shorthand properties first</h4>
        <pre>
          const anakinSkywalker = 'Anakin Skywalker';
          const lukeSkywalker = 'Luke Skywalker';

          // bad
          const obj = {
            episodeOne: 1,
            twoJediWalkIntoACantina: 2,
            lukeSkywalker,
            episodeThree: 3,
            mayTheFourth: 4,
            anakinSkywalker,
          };

          // good
          const obj = {
            lukeSkywalker,
            anakinSkywalker,
            episodeOne: 1,
            twoJediWalkIntoACantina: 2,
            episodeThree: 3,
            mayTheFourth: 4,
          };
        </pre>
        <pre>
          // bad
          const bad = {
            'foo': 3,
            'bar': 4,
            'data-blah': 5,
          };

          // good
          const good = {
            foo: 3,
            bar: 4,
            'data-blah': 5,
          };
        </pre>
        
      </div>
      <div class="col-sm-12">
        <h3>The different between let var and const</h3>
        <p><a target="_blank" href="https://github.com/airbnb/javascript">ES5 (Deprecated)</a>ES5(javascript已经被弃用)，ES6已经更新，事实上呢，前端发展飞速，众多框架，react，angular，vue，前端自动化工具gulp，grunt，包管理工具bower，甚至webpack项目搭建工具，node服务器搭建，等等五花八门迅速膨胀。以前以为变化再多，万变不离其宗，HTML,CSS,JS,这三大基础是不变的，现在css4即将出来，javascript甚至连基本的Var也将要被弃用。javascript使用人数迅速增加，github已经有50k星了，javascript开启"use strict"模式</p>
        <h4>the bug of var</h4>
        <pre class='brush: javascript'>
          var a = "b";
          var a = "a";//居然可以重复命名，c
          console.log(a);//输出"a"

          for(var i = 10 ; i>0; i--){
            var a = "a";
          }
          console.log(a);//输出:"a",,明明已经跳出循环了，居然还可以访问到里面的a变量，i=0，这不得不说是一个重大bug

          for(var i = 10; i>10; i--){
            setTimeout(function(){
              console.log(i); //so intersting with what will i console ;
                              //it console tenth of zero;if it's var ,the next turn can change the one before var it;
                              //that a big bug;so many people say that javascript is a lazy computer language;
            },1000)
          }
        </pre>
        <h4>let</h4>
        <p>Tip: 必须先声明"use strict"才能使用let变量进行声明，否则浏览器不会显示。</p>
        <p>首先声明，let和var很像，都是用来声明变量的，let声明的变量拥有块级作用域,let声明的全局变量不是全局对象的属性</p>
        <pre>
          var abs = "123";
          console.log(abs);//123

          let abs = "123";
          console.log(abs);//undefined
        </pre>
        <p>对于for循环这样的闭包函数，被一次循环let的变量虽然名字相同，但是是不同的变量名称。</p>
        <h4>const</h4>
        <p>const常量的命名，这没什么好说的。不能重复命名常量。</p>
        <p>both let and const are block-scoped</p>
        <pre>
          {
            let a = 1;
            const b = 2;
          }
          console.log(a,b);//referenceError ,both are undefined
        </pre>
      </div>
      <div class="col-sm-12">
        <h3>关于javascript----基础知识篇;</h3>
        <h4>注释(Comments)</h4>
        <pre class='brush: javascript'>
          // 单行注释
          
          /*这个是一个多行注释
           多行注释
          */
          
          /*你不能，但是，/*嵌套注释*/语法错误*/
        </pre>
        <h4>声明(Declarations)</h4>
        <p>javascript有三种声名。</p>
        <p>var</p>
        <p>声明变量，可选初始化值。</p>
        <p>let</p>
        <p>声明块范围局部变量，可选初始化值。</p>
        <p>const</p>
        <p>声明一个只读命名常量。</p>
        <h4>变量</h4>
        <p>在应用程序中，一个标识符必须以字母、下划线(_)或者美元符号开头;后续字母可以含(0~9)    。因为javascript语言是区分大小写的，这里所指的字母可以是大写英文字母也可以是小写的。</p>
        <p>var</p>
        <p>声明变量，可选初始化值。</p>
        <p>let</p>
        <p>声明块范围局部变量，可选初始化值。</p>
        <p>const</p>
        <p>声明一个只读命名常量。</p>
        <h4>声明变量</h4>
        <p>你可以用以下两种方式声明变量：</p>
        <pre class='brush: javascript'>
          使用关键词var。例如，var x = 42。这个语法可以同时声明局部和全局变量。
          直接赋值。例如，x = 42。这样就声明了一个全局变量，并导致javascript编译时候产生一个严格   警告。因而你应该避免使用这种非常规格式。
        </pre>
        <h4>对变量求值</h4>
        <p>用 var 或 let    声明时未赋初值的变量，值会被设定为undefined（即使未定义，本身也是一个值）。</p>
        <p>试图访问一个未初始化的变量会导致一个ReferenceError异常被抛出：</p>
        <pre class='brush: javascript'>
          var a;
          console.log("The value of a is " + a); // logs"The value of a is undefined"
          console.log("The value of b is " + b); // throw ReferenceError expection
        </pre>
        <script>
          /*var a;
          console.log("The value of a is "+a);
          console.log("The value of a is "+b);*/
        </script>
      </div>
      <div class="col-sm-12">
        <img src="build/images/QQ截图20151027223135.jpg" alt="">
        <p>抛出错误如图所示，当然你要在Firefox浏览器上才能看。</p>
        <p>你可以使用undefined来确定变量是否已赋值。以下代码中，变量input未被赋值，因而if条件语   句的求值结果是true。</p>
        <pre class='brush: javascript'>
          var input;
          if(input === undefined){
            doThis();
          }else{
            doThat();
          }
        </pre>
    
        <script>
          /*var input;
          if (input === undefined) {
            console.log("undefined")
            console.log(input)
          }else{
            console.log("defined")
            console.log(input)
          }*/
        </script>
        <P>soso~,input is undefined!and you can see this in firbug</P>
        <img src="build/images/QQ截图20151027224323.jpg" alt="">
        <p>undefined值在布尔类型环境中会被当作false。例如，下面的代码将运行函数myFunction，因为   数组myArray中的元素未被赋值：</p>
        <pre class='brush: javascript'>
          var myArray = new Array();
          if(!myArray[0])myFunction();
        </pre>
        <script>
          /*var myArray = new Array();
          if (!myArray[0]) {myFunction()};
          function myFunction (){
            console.log(myArray[0]);
          }*/
        </script>
        <img src="build/images/haserror.jpg" alt="">
        <img src="build/images/noerror.jpg" alt="">
        <p>请仔细观察下面两张图，包含三个点的内容</p>
        <pre class='brush: javascript'>
          undefined值在布尔类环境中会被当作false。如图所示
          第一张图我们用var func = function(){}来定义函数。
          第二张图我们用functionfunc(){}来定义函数，该函数的优先解释等级先于同一语句级的其他语    句
        </pre>
      </div>
      <div class="col-sm-12">
        <p>数值类型环境中undefined值会被转换为NaN(not a number)。</p>
        <pre class='brush: javascript'>
          var a;
          a + 2 = NaN;
        </pre>
    
          <script>
            /*var a;
            console.log(a+2)*/
          </script>
        <img src="build/images/QQ截图20151027234142.jpg" alt="">
        <p>当你对一个空变量求值时候，空值null在数值类型环境中会被当作0来对待，而布尔类型环境中会    被当作false</p>
        <pre class='brush: javascript'>
          var n = null;
          console.log(n*32);
        </pre>
        <script>
          /*var n = null;
          if (!n) {
            console.log(n*32);
            console.log(typeof n);
          };*/
        </script>
        <img src="build/images/QQ截图20151027235101.jpg" alt="">
        <img src="build/images/QQ截图20151028000001.jpg" alt="">
      </div>
      <div class="col-sm-12">
        <h3>变量的域</h3>
        <p>在所有函数之外声明的变量，叫做全局变量，因为它可能被当作文档中的其他代码所访问。在函数    内部声明的变量，叫做局部变量名，因为它只能在该函数内部访问。</p>
        <p>Javascript没有语句块作用域;相反，语句块中声明的变量将成为语句块所在代码段的局部变量。   例如，如下的代码将在控制台输出5,因为x的作用域是声明了x的那个函数(或全局范围)   ，而不是if语句块。</p>
        <pre class='brush: javascript'>
            if(true){
              var x = 5;
            }
            console.log(x); //5
        </pre>
        <h4>变量声明提示</h4>
        <p>Javascript变量的另一特别之处在于，你可以引用稍后声明的变量，而不会发生异常。这一概念称   为变量声明提升(hoisting);javascript变量感觉上是被“举起”或者提升到了所有函数和语句之前。   但是，未被初始化的变量仍然返回undefined值。</p>
        <pre class='brush: javascript'>
          /**
          * Example 1
          */
          console.log(x===undefined); // log "true"
          var x = 3;
          
          
          /**
          * Example 2
          */
          // will return a value of undefined
          var myvar = "my value"
          
          (function(){  //匿名函数
            console.log(myvar); //undefined
            var myvar = "local value";
          })();
        </pre>
        <p>上面的例子2，也可以写作：</p>
        <pre class='brush: javascript'>
          /**
          * Example 1
          */
          var x = 3;
          console.log(x===undefined); // log "true"
          x = 3;
          
          /**
          * Example 2
          */
          // will return a value of undefined
          var myvar = "my value"
          
          (function(){  //匿名函数
            var myvar;
            console.log(myvar); //undefined
            var myvar = "local value";
          })();
        </pre>
        <p>由于存在变量声明提升，一个函数中所有的var语句应尽可能的放在接近函数顶部的地方。这大大   提升了函数代码的清晰度。</p>
        <h4>全局变量</h4>
        <p>全局变量实际上是<i>全局对象的</i>属性。在网页中，（译注：缺省的）全局对象是window，所    以你可用形如window.variable的语法来设置和访问全局变量。</p>
        <p>因此，你可以通过指定window或frame的名字，从一个window或frame访问另一个window或frame   中声明的变量。例如，设想一个叫phoneNumber的变量在文档FRAMESET里被声明，你可以在子框架里   用parent.phoneNumber来引用它。</p>
        <h4>常量</h4>
        <p>你可以用关键字const创建一个只读的常量。常量标识符的命令规则和变量的相同：必须以字母、下   划线或美元符号开头并可以包含有字母、数字、下划线。</p>
        <pre class="brush: javascript">const prefix = '212';</pre>
      </div>
    
      <div class="col-sm-12">
        <p>常量不可以通过赋值改变其值，也不可以在脚本运行时候重新声明。</p>
        <p>常量，包括全局常量，都必须带const关键字，除此之外，常量的作用域规则与变量相同。若const   关键字被省略了，该标识符将被视为变量。</p>
        <p>在同一作用域中，不能用与变量或函数同样的名字来命名常量。例如：</p>
        <pre class="brush: javascript">
          // THIS WILL CAUSE AN ERROR
          function f() {};
          const f = 5;
          
          // THIS WILL CAUSE AN ERROR
          function f(){
            
          }
        </pre>
        <h4>关于对象的创建</h4>
        <p>关于创建对象的两种方法</p>
        <pre class="brush: javascript">
          var obj = new object();
        </pre>
        <p>和：</p>
        <pre class="brush: javascript">
          var obj =  {};
        </pre>
        <p>这两种方法在语义上是相同的。第二种更方便的方法叫做“对象字面量（object     literal）”法。这种也是JSON格式的核心语法，一般我们优先选择第二种方法。</p>
        <p>"对象字面量"也可以用来在对象实例中定义一个对象：</p>
        <pre class="brush: javascript">
          var obj = {
            name: "Carrot",
            "for": "Max",
            details: {
              color: "orange",
              size: 12,
            },
          }
        </pre>
        <p>对象的属性也可以通过链式（chain）表示方法进行访问：</p>
        <pre class="brush: javascript">
          obj.details.color; //orange
          obj['details']['size']; //12
        </pre>
        <p>下面的例子创建了一个对象原型，Person，和这个原型的实例，You。</p>
        <pre class="brush: javascript">
          function Person(name,age){
            this.name = name;
            this.age = age;
          }
    
          //定义一个对象
          var You = new Person("You" , 24);
          // 我们创建了一个新的Person，名称是 "You"
          // ("You" 是第一个参数，24 是第二个参数..)
        </pre>
    
        <p>关于循环</p>
        <pre class="brush: javascript">
          var a = [1,1,1,1];
          /*低效循环*/
          for(var i = 0 ; i < a.length ; i++) {
            console.log(i)
          }
    
          /*中效循环*/
          for(var i = 0 , len = a.length ; i < len ; i++) {
            console.log(i)
          }
    
          /*高效循环，但是与前两种有区别，当遇到一个元素为undefined时候，循环结束，这个技巧只能    当你知道数组中不含假元素（如undefined）时，循环结束。*/
          for(var i = 0 , item ; item = a[i++];) {
            console.log(i)
          }
    
          /*另一种循环方式，便利数组的另一种方式是使用for...in循环。注意，如果有人向Array.protot    ype添加了新的属性，使用这样的循环这些属性也同样会被遍历，但并不推荐这种方法：*/
          
          var a = [1,1,1,1]
          for(var i in a){
            console.log(a[i])
          }
        </pre>
        </div>
      <div class="col-sm-12">
        <p>ECMAScript 5 增加了遍历数组的另一种方法 foreach():</p>
        <pre class="brush: javascript">
          ["dog", "cat", "hen"].forEach(function(currentValue, index, array) {
            // Do soomething with currentValue or array[index]
          });
        </pre>
        <h4>函数</h4>
        <p>学习javascript最重要的是要去理解对象和函数两个部分。最简单的函数就像下面这个这么简单：   </p>
        <pre class="brush: javascript">
          function add(x,y){
            var total = x + y;
            return total;
          }
        </pre>
        <p>这个例子包括你需要了解的关于基本函数的所有部分。一个javascript函数可以包含0个或多个已   命名的变量。函数体中的表达式数量也没有限制。你可以声明函数自己的局部变量。return语句在返回  一个值并结束函数。如果没有使用return语句，或者一个没有值得return语句，javascript会返回un   defined。</p>
        <p>已命名的参数更像是一个指示而没有其他作用。如果调用函数没有提供足够的参数，缺少的参数会    被undefined替代。</p>
        <pre class="brush: javascript">
          add(); //NaN
          // 不能在 undefined 对象上进行加法操作
        </pre>
        <p>你还可以传入多余函数本身需要参数个数的参数：</p>
        <pre class="brush: javascript">
          add(2,3,4); // 5
          // 将前面两个值相加，4被忽略了
        </pre>
        <p>这个看上去有点蠢。函数实际上是访问了函数体中一个名为 arguments 的内部对象，这个对象就   如同一个类似于数组的对象一样，包括了所有被传入的参数。让我们重写上面的函数，使它可以接收任   意个数的参数：</p>
        <pre class="brush: javascript">
          function add(){
            var sum = 0;
            for (var i = 0, j = arguments.length; i < j ; i++){
              sum += arguments[i];
            }
            return sum;
          }
    
          add(2,3,4,5);
        </pre>
        <h4>匿名函数</h4>
        <pre class="brush: javascript">
          var avg = function() {
            var sum = 0;
            for (var i = 0 , j = arguments.length ; i < j.length; i++) {
              sum += arguments[i];
            };
            return sum / arguments.length;
          }
          console.log(avg([2,3,4,4]));
        <h4>匿名函数之有趣的技巧</h4>
        <pre class="brush: javascript">
          var a = 1;
          var b = 2;
          (function(){
            var b = 3;
            a += b;
          })();
          console.log(a); //4
          console.log(b); //2
        <h4>递归函数</h4>
        <p>javascript允许以递归方式调用函数。递归在处理树形结构（比如浏览器DOM）时非常有用。</p>
        <pre class="brush: javascript">
          function countchars(elm) {
            if (elm.nodeType == 3) {
              return elm.nodeValue.length;
            }
            var count = 0;
            for (var i = 0, child; child = elm.childNodes[i]; i++) {
              count += countchars(child);
            };
            return count;
          }
        </pre>
        <p>这里需要说明一个潜在问题--既然匿名函数没有名字，那么该怎么递归调用它呢？在这一点上，ja    vascript允许你命名这个函数表达式。你可以命名立即调用函数表达式（IIFES--Immediately    Invoked Function Expressions）,如下所示：</p>
        <pre class="brush: javascript">
          var charsInBody = (function counter(elm) {
            if (elm.nodeType == 3) { //文本节点
              return elm.nodeValue.length;
            }
            var count = 0;
            for (var i = 0, child; child = elm.childNodes[i]; i++) {
              count += counter(child);
            }
            return count;
          })(document.body);
        </pre>
      </div>
    
      <div class="col-sm-12">
        <h3>关于canvas的应用</h3>
        <p>canvas属于html5里面最强大的元素。canvas，顾名思义就是指的画板，运用canvas+javascrip   t，可以绘制出一片美丽的星空,下面首先我先做一个demo吧，下面的demo是最基本直线绘制。</p>
        <canvas id="canvas" style="border:1px solid #aaa;display:block;margin:50px auto;"   ></canvas>
        <script>
          function canvas_func(){
            var canvas = document.getElementById("canvas");
            canvas.width = 800;
            canvas.height = 800;
            var context = canvas.getContext("2d");
            context.lineWidth=10;
            context.beginPath();
            context.moveTo(100,100);
            context.lineTo(400,400);
            context.lineTo(100,700);
            context.strokeStyle = "red";
            context.stroke();
            context.closePath();
            context.beginPath();
            context.moveTo(200,100);
            context.lineTo(500,400);
            context.lineTo(200,700);
            context.strokeStyle = "green";
            context.stroke();
            context.closePath();
            context.beginPath();
            context.moveTo(300,100);
            context.lineTo(600,400);
            context.lineTo(300,700);
            context.strokeStyle = "blue";
            context.stroke();
            context.closePath();
            context.beginPath();
            context.moveTo(400,100);
            context.lineTo(700,400);
            context.lineTo(400,700);
            context.strokeStyle = "yellow";
            context.stroke();
            context.closePath();
          }
        </script>
        <p>首先在HTML页面引入canvas元素！</p>
        <pre class='brush: javascript'>
          <canvas id="canvas" style="border:1px solid #aaa;display:block;margin:50px auto   ;"></canvas>
        </pre>
      </div>
      <div class="col-sm-12">
        <p>然后就需要我们引入js代码</p>
        <pre class='brush: javascript'>
          <script>
            function canvas_func(){
              var canvas = document.getElementById("canvas");
              canvas.width = 800;
              canvas.height = 800;
              var context = canvas.getContext("2d");
              context.lineWidth=10;
              context.beginPath();
              context.moveTo(100,100);
              context.lineTo(400,400);
              context.lineTo(100,700);
              context.strokeStyle = "red";
              context.stroke();
              context.closePath();
              context.beginPath();
              context.moveTo(200,100);
              context.lineTo(500,400);
              context.lineTo(200,700);
              context.strokeStyle = "green";
              context.stroke();
              context.closePath();
              context.beginPath();
              context.moveTo(300,100);
              context.lineTo(600,400);
              context.lineTo(300,700);
              context.strokeStyle = "blue";
              context.stroke();
              context.closePath();
              context.beginPath();
              context.moveTo(400,100);
              context.lineTo(700,400);
              context.lineTo(400,700);
              context.strokeStyle = "yellow";
              context.stroke();
              context.closePath();
            }
          </script>
        </pre>
      </div>
    </div>
    
    
    <footer>
    </footer>
    
    <script src="../lib/bootstrap/dist/js/bootstrap.min.js"></script>